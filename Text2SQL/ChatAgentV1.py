"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_ChatAgentV1.ipynb.

# %% auto 0
__all__ = ['MD', 'create_system_prompt', 'md_user', 'str2key_value', 'md_tool', 'md_assistant']

# %% ../nbs/01_ChatAgentV1.ipynb 2
from .SnowflakeCore import *
from lisette import *
import pandas as pd
import ast
import regex as re
import json

# %% ../nbs/01_ChatAgentV1.ipynb 3
from IPython.display import Markdown, display
MD = lambda x: display(Markdown(x))

# %% ../nbs/01_ChatAgentV1.ipynb 4
def create_system_prompt(schema: ParentSchema) -> str:
    return f"""You are a SQL query generator for {schema.dialect}.

DATABASE: {schema.database}.{schema.Schema}
SCHEMA: {schema.model_dump_json(indent=2)}

CORE RULES:
1. Generate SELECT queries only - no modifications
2. ALWAYS quote identifiers: SELECT "column_name" FROM "table_name"
3. Use fully qualified names: {schema.database}.{schema.Schema}."TABLE_NAME"
4. No semicolons - single statement only
5. Use the execute_query tool to run queries
6. Use pyhon's triple quotes to format the query

JSON COLUMNS:
- Many columns store JSON as VARCHAR (see samples)
- To extract values: GET(PARSE_JSON("column_name"), 'key')::VARCHAR
- Example: GET(PARSE_JSON("airport_name"), 'en')::VARCHAR

NULL VALUES:
- Sample data shows '\\N' but use IS NULL / IS NOT NULL in WHERE clauses

ERROR RECOVERY:
- If query fails, check: quoted identifiers, table/column names, JSON syntax
- Analyze error message and retry with corrections

Be precise and efficient."""


# %% ../nbs/01_ChatAgentV1.ipynb 13
def md_user(msg):
    """Format user message with quote styling"""
    content = msg.get('content', '') if isinstance(msg, dict) else msg.content
    
    return f"""### üë§ **User**

> {content}
"""

# %% ../nbs/01_ChatAgentV1.ipynb 21
def str2key_value(msg:str):
    """
    Extracts key and value from a message string.

    Args:
        msg (str): The message string to extract tools from.
        Ex: `'query=\'SELECT "departure_airport", COUNT(*) AS "departures" FROM AIRLINES.AIRLINES."FLIGHTS" WHERE "scheduled_departure" IS NOT NULL GROUP BY "departure_airport" ORDER BY "departures" ASC LIMIT 1\' success=True data=[{\'departure_airport\': \'USK\', \'departures\': 18}] error=None row_count=1 execution_time=0.3334343433380127'`

    Returns:
        dict: A dictionary of tools extracted from the message string.
        Ex:
        {'query': 'SELECT "departure_airport", COUNT(*) AS "departures" FROM AIRLINES.AIRLINES."FLIGHTS" WHERE "scheduled_departure" IS NOT NULL GROUP BY "departure_airport" ORDER BY "departures" ASC LIMIT 1',
        'success': True,
        'data': [{'departure_airport': 'USK', 'departures': 18}],
        'error': None,
        'row_count': 1,
        'execution_time': 0.3334343433380127}

    """
    pattern = r"(\w+)=(.+?)(?=\s+\w+=|\s*$)"
    matches = re.findall(pattern, msg)
    parsed = {}
    for key, value in matches:
        try:
            # Try to evaluate as Python literal
            parsed[key] = ast.literal_eval(value.strip())
        except (ValueError, SyntaxError):
            # If it fails, keep as string
            parsed[key] = value.strip()
    return parsed

# %% ../nbs/01_ChatAgentV1.ipynb 24
def md_tool(dic):
    """Compact tool result formatting"""
    content = str2key_value(dic.get('content', ''))
    
    success = content.get('success', False)
    data = content.get('data', [])
    row_count = content.get('row_count', 0)
    exec_time = content.get('execution_time', 0)
    
    base_str = f"""### üõ†Ô∏è **Tool**
__Executed: {dic.get('name', '')}__

"""
    
    if not success:
        return base_str + f"‚ùå **Error:** {content.get('error')}"
    
    # Format first few rows
    if data:
        df = pd.DataFrame(data[:5])  # First 5 rows
        table = df.to_markdown(index=False)
    else:
        table = "_No data_"
    
    return base_str + f"""‚úÖ **Result** ({row_count} rows, {exec_time:.2f}s)

{table}
"""

# %% ../nbs/01_ChatAgentV1.ipynb 27
from litellm.types.utils import Message
def md_assistant(msg:Message):
    """Format message as markdown - handles both tool calls and regular responses"""
    
    # Check if this is a tool call message
    if msg.tool_calls and len(msg.tool_calls) > 0:
        # Format tool call
        try:
            func = msg.tool_calls[0]['function']
            args = json.loads(func['arguments'])
            query = args.pop('query', '')
            
            query_section = f"""<details>
<summary><b>üìù Query</b></summary>

```sql
{query}
```
"""  if query else ''
            #query_section = f">**Query:**\n```sql\n{query}\n```\n" if query else ''
            
            args_table = (
                "\n| Parameter | Value |\n|-----------|-------|\n" + 
                "\n".join(f"| **{k}** | `{v}` |" for k, v in args.items())
            ) if args else ""
            
            reasoning = msg.reasoning_content or "No reasoning provided"
            
            return f"""### üß† Assistant \n\n
_Reasoning: {reasoning}_

**Call: {func['name']}**

{query_section}{args_table}

"""
        except (IndexError, KeyError, json.JSONDecodeError) as e:
            return f"‚ùå Error formatting tool call: {e}"
    
    else:
        # Regular assistant message (no tool calls)
        reasoning = msg.reasoning_content or ""
        reasoning_section = f"\n\nüí≠ _Reasoning: {reasoning}_" if reasoning else ""
        
        return f"""ü§ñ **Assistant**

{msg.content}{reasoning_section}
"""
